---- Dockers et conteneurs ----------- https://www.youtube.com/watch?v=AWJG-AbGFik&list=PLn6POgpklwWq0iz59-px2z-qjDdZKEvWd&index=2

conteneur : processus pour faire tourner l'image

Image = package de code et déendance, inactif, stocké sur un registry distant tq docker hub (par defaut).
On le ramène au niveau local pour travailler avec

Conteneur : l'activation d'une image de manière à faire tourner un processus
On peut lancer plusieurs conteneurs pour la meme image

Vous pouvez avoir un serveur pour stocker votre image, ce serveur sera votre registry pour les images

---- Installation

 $ cat premier-pas.sh

#!/usr/bin/bash

## Suppression de la précédente version de Docker

sudo apt remove docker docker-engine docker.io containerd runc

## Mise en place du dépôt Docker

sudo apt install ca-certificates curl gnupg lsb-release
sudo mkdir -m 0755 -p /etc/apt/keyrings

# Pour copier la clé gpg de docker dans le rep local /etc/apt/keyrings:
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmorг -o /etc/apt/keyrings/docker.gpg

echo \
"deb [arch=$(dpkg --print-architecture) signé-par=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \

$(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

## Installation de docker

sudo apt update
sudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

---- 
sudo docker ps 					: voir les conteneurs actifs
sudo docker ps -a		: voir les conteneurs actifs ou pas
sudo docker run nginx:latest	: check et lance un conteneur nginx si l'image existe localement sinon télécharge l'image nginx sur docker hub par défaut
								  et rapatrie l'image localement

sudo docker run -d nginx:latest : option -d ou detached pour lancer le conteneur en background et donner la main au niveau os

sudo usermod -aG docker $USER	: Ajouter le user courant dans le group "docker2 pour éviter de préciser sudo

docker run
	-d	: mode detach ou background
--name	: définir le nom du conteneur

Image
<url_registry>/<nom_image>:<tag>

------------
docker run -d --name c1 nginx:latest   : Crée un conteneur c1
docker stop c1
docker start c1
docker ps -a
docker rm -f c1 	: force l'arret et supprime c1

docker run -ti --name c1 nginx:latest  : lance le conteneur en mode interactif

docker run -ti --rm --name c1 debian:latest   : lance une machine linux debian où on y accède en mode root
												--rm permet de supprimer le conteneur une fois qu'on quitte c1
						
docker run -ti --rm --name c1 --hostname host1 debian:latest   : le hostname de la machine linux/debian sera host1

On peut ajouter l'option --dns 8.8.8.8 par exemple si le conteneur n'arrive pas à joindre ce dns

docker ps -q 	: Liste les ids de l'ens des conteneurs actifs  (-qa pour inclure les inactifs)
docker rm -f $(docker ps -q)	: supprime une liste de conteneurs suivant leurs ids

------------ Les volumes

	• facile pour persister de la donnée
	• pratique pour faire des backups
	• partager entre de multiple conteneurs
	• multiconteneurs et permissions
	• locaux ou distants (nfs, samba, etc)

docker volume ls 	: voir les volumes existants
docker volume create myngnix	: créer un volume myngnix

docker run -d --name c1 -v myngnix:/usr/share/nginx/html nginx:latest

docker exec -ti c1 bash	: la commande qu'on veut passer au c1 en interactif. Ici on s'accroche en réalité au conteneur c1

dans c1 : ls /usr/share/nginx/html

docker volume inspect myngnix 	: voir le contenu du volume

[
	{
		"CreatedAt": "2023-02-23T16:37:40Z",
		"Driver": "local",
		"Labels": null,
		"Mountpoint": "/var/lib/docker/volumes/mynginx/_data",		: point de montage sur le host local en dehors du conteneur
		"Name": "mynginx",
		"Options": null,
		"Scope": "local"
	}
]

Si on ajoute/modifie un fichier dans /usr/share/nginx/html dans c1, on pourra voir cela en local dans /var/lib/docker/volumes/mynginx/_data

On peut créer un debian c2 avec un autre point de montage, qui utilise le meme volume mynginx :

docker run -ti --name c2 --rm -v myngnix:/data debian:latest bash
si on fait "ls /data", on retrouve bien les fichiers dans /usr/share/nginx/html

Toute modification à partir de c2 est visible aussi via c1

docker volume rm mynginx 	: suppession du volume créé en local qui échoue car volume utilisé.
							   Avant de supprimer, les conteneurs utilisant le volume doivent être supprimés ou au moins arrêtés
							
--------- Les types de volumes

- Bind mount sous linux : permet de monter un rép dans un autre rép

sudo mount --bind /data  /data2
sudo findmnt 

/data2 ..... /data			: data2 monté ou ayant sa source sur /data

$ls /data2			: affiche le contenu de /data

sudo umount /data2  : supprime le montage /data2

--- Les types de volume dans docker :

	Bind mount	  (persistant)
	Volume docker (persistant)	: Cas déjà étudié
	TMPFS

Avec bind volume, on surcharge le conteneur avec un dossier, qui va donc écraser le contenu du rép dans le conteneur qui sera créé.
Avec volume docker, c'est l'inverse : c'est le volume créé dans le conteneur qui écrit dans le volume local
Avec tmpfs, on aura un espace de travail en memoire non persistant

• -v ου --volume

	• if volume name = volume
	• if path = bind

• --mount + type

	• type = bind / volume / tmpfs

--- Bind mount 

	docker run -d --name cl
  --mount type=bind,
	source=/data/,
	target=/usr/share/nginx/html
	nginx:latest

	Option: readonly /,readwrite

docker run -d --name c1 --mount type=bind,source=/data/,destination=/usr/share/nginx/html/ nginx:latest
docker exec -ti c1 bash

dans c1:
	ls /usr/share/nginx/html

Si on fait en local :
$ docker inspect c1 : On verra les infos sur la source et destination

$ docker inspect --format "{{.Mounts}}" c1
--> [{bind  /data /usr/share/nginx/html true rprivate}]


---- Volume

	docker run -d --name cl
  --mount type=volume,
	src=myvolume, target=/usr/share/nginx/html
	nginx:latest

$ docker volume create mynginx
mynginx

$ docker volume ls			: NB les volumes de type bind n'apparaissent pas dans la liste des volumes créés avec cette commande; pas managés par docker

DRIVER 	VOLUME NAME
local 	mynginx

$ docker run -d --name c2 --mount type=volume,src=mynginx, destination=/usr/share/nginx/html nginx:latest

$ docker exec -ti c2 bash

root@7c735700047c:/# ls /usr/share/nginx/html/
index.html

---- TMPFS

docker run -d --name cl

  --mount type=tmpfs, 
	destination=/usr/share/nginx/html 
	nginx:latest

$ docker run -d --name c3 --mount type=tmpfs,destination=/usr/share/nginx/html nginx:latest
4543961077639ff6d389112c07ee3d6c9ffe9f886670d46b25a084202f7c117d

$ docker exec -ti c3 bash

root@45439b107763:/# echo toto > /usr/share/nginx/html/index.html
root@45439b107763:/# cat /usr/share/nginx/html/index.html
toto

Si on supprime et recrée le conteneur avec la meme dest, on ne retrouve plus le fichier index.html créé

----- Les utilisateurs et privilèges

- Interaction entre les users à l'interieur du conteneur et sur le host
- Ce sont les ids des users qui vont primer et non les noms

Sur la machine host locale :

#useradd -u 1111 user1
#useradd -u 1112 user2
#mkdir test
#cd test
#vim Dockerfile   : Fichier généralement utilsé pour créer une image

FROM debian:laste    		<---- Image source qu'on souhaite utiliser

RUN	useradd 1111 user1 	  	<---- RUN permey de lancer des commandes shell au moment du build de notre image. On créé un user1 identique à celui sur le host
RUN	useradd 1113 user3		<---- User non existant sur le host
:x!


# docker build -t myimage:v1.0 .    : Crée une image nommée "myimage" . Le "." permet de symboliser le fichier "dockerfile"
# docker images 					:  Pour voir les images contenues sur notre cache local de docker
REPOSITORY  TAG        	IMAGE ID        CREATED   		SIZE
myimage     v1.0       	c8331156e151    14 seconds ago	125MB
nginx		latest 		3f8a00f137a0 	3 weeks ago		142MB
debian		latest		54e726b437fb	3 weeks ago		124MB


# mkdir /myvolume
# docker run -d --name c1 -v /myvolume/:/data/myimage:v1.0   : Crée un conteneur mais qui ne tourne pas en background.
																Il n'est visible qu'avec option -a de "docker ps"
# docker rm -f c1
# docker run -d --name c1 -v /myvolume/:/data/  myimage:v1.0 sleep infinity   : tourne sans arrêt

dans c1:

root@docker1:/home/vagrant/test# docker exec -ti c1 bash  
root@2296f9a074fb:/# ls /data
root@2296f9a074fb:/# touch /data/titi
root@2296f9a074fb:/#

Au niveau host :

root@docker1:/home/vagrant# ls -la /myvolume/
total 8
drwxr-xr-x 2 root root 4096 Маг 3 13:39
drwxr-xr-x 21 root root 4096 Маг 3 13:36 ..
- ٢ - - ٢ - ٢٠ -- 1 root root 0 Маг 3 13:39 titi    <--- Le fichier est créé avec user root car c'est le user par défaut si aucun user spécifié à la creation de l'image

Relançons c1 avec user1:

#docker rm -f c1
# docker run -d --name c1 -v /myvolume/:/data/ -u user1 myimage:v1.0 sleep infinity 

# docker exec -ti c1 bash  	: On est connecté par defaut avec user1 qui n'a pas les droits d'écrire dans /data

Donner les droits à user1 au niveau host (ici owner)
#chown user1 /myvolume

Si on recrée c1 avec user3, user3 ne pourra lire dans /data que si on fait chmod 777 * sur le volume. 
Tout fichier créé par user3 aura l'id 1113 sans nom spécifié au niveau host

NB: On remapper à la création le root du conteneur pour ne pas le fait correspondre au root du host qui a l'id 0

--------------  Les containers runtime 

--OCI : Open Container Initiative

OCI a pour vocation de definir des normes en matière d'images de conteneurs. Ces normes sont sur le depot githud de OCI.
3 elements portés dans OCI :
1.Les layers : couches de filesystems mis les unes sur les autres
2.Les manifets : permettent de definir les architectures possibles pour l'image
3.Les configs : lignes de commandes our arguments dans l'image

Docker CLI est l'interface user en mode terminal qui permet de communiquer avec dockerd, le moteur docker ou container manager.
C'est un conteneur runtime de haut niveau.

Une couche de haut niveau permet d'y rajouter des couches supplementaires sur des conteneurs runtime de bas niveau
Ex: Dockerd permet de faire build ou inspecter une image, pull / push d'images, se connecter à une image avec exec

Dockerd utilise aussi un conteneur runtime haut niveau nommé containerd. Containerd permet de lancer des conteneurs (runc),
administrer le network des conteneurs et faire des bridges

runc : runtime de bas niveau, écrit en Go, permet de lancer les containers avec dockerd et containerd 
runc lance les conteneurs à partir d'images de type oci. Ce principe s'adosse aux principes de Cgroup et Namespaces

Cgroups ou Control Group : limitation des ressources (CPU, mem, NW, disk, priorités) allouées aux processus
Namespaces : isolation (PID, NW, Mount, IPC, UTS(Unix Time-Sharing))










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































v