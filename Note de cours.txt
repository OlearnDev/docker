---- Dockers et conteneurs ----------- https://www.youtube.com/watch?v=AWJG-AbGFik&list=PLn6POgpklwWq0iz59-px2z-qjDdZKEvWd&index=2

conteneur : processus pour faire tourner l'image

Image = package de code et déendance, inactif, stocké sur un registry distant tq docker hub (par defaut).
On le ramène au niveau local pour travailler avec

Conteneur : l'activation d'une image de manière à faire tourner un processus
On peut lancer plusieurs conteneurs pour la meme image

Vous pouvez avoir un serveur pour stocker votre image, ce serveur sera votre registry pour les images

---- Installation

 $ cat premier-pas.sh

#!/usr/bin/bash

## Suppression de la précédente version de Docker

sudo apt remove docker docker-engine docker.io containerd runc

## Mise en place du dépôt Docker

sudo apt install ca-certificates curl gnupg lsb-release
sudo mkdir -m 0755 -p /etc/apt/keyrings

# Pour copier la clé gpg de docker dans le rep local /etc/apt/keyrings:
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmorг -o /etc/apt/keyrings/docker.gpg

echo \
"deb [arch=$(dpkg --print-architecture) signé-par=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \

$(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

## Installation de docker

sudo apt update
sudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

---- 
sudo docker ps 					: voir les conteneurs actifs
sudo docker ps -a		: voir les conteneurs actifs ou pas
sudo docker run nginx:latest	: check et lance un conteneur nginx si l'image existe localement sinon télécharge l'image nginx sur docker hub par défaut
								  et rapatrie l'image localement

sudo docker run -d nginx:latest : option -d ou detached pour lancer le conteneur en background et donner la main au niveau os

sudo usermod -aG docker $USER	: Ajouter le user courant dans le group "docker2 pour éviter de préciser sudo

docker run
	-d	: mode detach ou background
--name	: définir le nom du conteneur

Image
<url_registry>/<nom_image>:<tag>

------------
docker run -d --name c1 nginx:latest   : Crée un conteneur c1
docker stop c1
docker start c1
docker ps -a
docker rm -f c1 	: force l'arret et supprime c1

docker run -ti --name c1 nginx:latest  : lance le conteneur en mode interactif

docker run -ti --rm --name c1 debian:latest   : lance une machine linux debian où on y accède en mode root
												--rm permet de supprimer le conteneur une fois qu'on quitte c1
						
docker run -ti --rm --name c1 --hostname host1 debian:latest   : le hostname de la machine linux/debian sera host1

On peut ajouter l'option --dns 8.8.8.8 par exemple si le conteneur n'arrive pas à joindre ce dns

docker ps -q 	: Liste les ids de l'ens des conteneurs actifs  (-qa pour inclure les inactifs)
docker rm -f $(docker ps -q)	: supprime une liste de conteneurs suivant leurs ids

------------ Les volumes

	• facile pour persister de la donnée
	• pratique pour faire des backups
	• partager entre de multiple conteneurs
	• multiconteneurs et permissions
	• locaux ou distants (nfs, samba, etc)

docker volume ls 	: voir les volumes existants
docker volume create myngnix	: créer un volume myngnix

docker run -d --name c1 -v myngnix:/usr/share/nginx/html nginx:latest

docker exec -ti c1 bash	: la commande qu'on veut passer au c1 en interactif. Ici on s'accroche en réalité au conteneur c1

dans c1 : ls /usr/share/nginx/html

docker volume inspect myngnix 	: voir le contenu du volume

[
	{
		"CreatedAt": "2023-02-23T16:37:40Z",
		"Driver": "local",
		"Labels": null,
		"Mountpoint": "/var/lib/docker/volumes/mynginx/_data",		: point de montage sur le host local en dehors du conteneur
		"Name": "mynginx",
		"Options": null,
		"Scope": "local"
	}
]

Si on ajoute/modifie un fichier dans /usr/share/nginx/html dans c1, on pourra voir cela en local dans /var/lib/docker/volumes/mynginx/_data

On peut créer un debian c2 avec un autre point de montage, qui utilise le meme volume mynginx :

docker run -ti --name c2 --rm -v myngnix:/data debian:latest bash
si on fait "ls /data", on retrouve bien les fichiers dans /usr/share/nginx/html

Toute modification à partir de c2 est visible aussi via c1

docker volume rm mynginx 	: suppession du volume créé en local qui échoue car volume utilisé.
							   Avant de supprimer, les conteneurs utilisant le volume doivent être supprimés ou au moins arrêtés
							
--------- Les types de volumes

- Bind mount sous linux : permet de monter un rép dans un autre rép

sudo mount --bind /data  /data2
sudo findmnt 

/data2 ..... /data			: data2 monté ou ayant sa source sur /data

$ls /data2			: affiche le contenu de /data

sudo umount /data2  : supprime le montage /data2

--- Les types de volume dans docker :

	Bind mount	  (persistant)
	Volume docker (persistant)	: Cas déjà étudié
	TMPFS

Avec bind volume, on surcharge le conteneur avec un dossier, qui va donc écraser le contenu du rép dans le conteneur qui sera créé.
Avec volume docker, c'est l'inverse : c'est le volume créé dans le conteneur qui écrit dans le volume local
Avec tmpfs, on aura un espace de travail en memoire non persistant

• -v ου --volume

	• if volume name = volume
	• if path = bind

• --mount + type

	• type = bind / volume / tmpfs

--- Bind mount 

	docker run -d --name cl
  --mount type=bind,
	source=/data/,
	target=/usr/share/nginx/html
	nginx:latest

	Option: readonly /,readwrite

docker run -d --name c1 --mount type=bind,source=/data/,destination=/usr/share/nginx/html/ nginx:latest
docker exec -ti c1 bash

dans c1:
	ls /usr/share/nginx/html

Si on fait en local :
$ docker inspect c1 : On verra les infos sur la source et destination

$ docker inspect --format "{{.Mounts}}" c1
--> [{bind  /data /usr/share/nginx/html true rprivate}]


---- Volume

	docker run -d --name cl
  --mount type=volume,
	src=myvolume, target=/usr/share/nginx/html
	nginx:latest

$ docker volume create mynginx
mynginx

$ docker volume ls			: NB les volumes de type bind n'apparaissent pas dans la liste des volumes créés avec cette commande; pas managés par docker

DRIVER 	VOLUME NAME
local 	mynginx

$ docker run -d --name c2 --mount type=volume,src=mynginx, destination=/usr/share/nginx/html nginx:latest

$ docker exec -ti c2 bash

root@7c735700047c:/# ls /usr/share/nginx/html/
index.html

---- TMPFS

docker run -d --name cl

  --mount type=tmpfs, 
	destination=/usr/share/nginx/html 
	nginx:latest

$ docker run -d --name c3 --mount type=tmpfs,destination=/usr/share/nginx/html nginx:latest
4543961077639ff6d389112c07ee3d6c9ffe9f886670d46b25a084202f7c117d

$ docker exec -ti c3 bash

root@45439b107763:/# echo toto > /usr/share/nginx/html/index.html
root@45439b107763:/# cat /usr/share/nginx/html/index.html
toto

Si on supprime et recrée le conteneur avec la meme dest, on ne retrouve plus le fichier index.html créé

----- Les utilisateurs et privilèges

- Interaction entre les users à l'interieur du conteneur et sur le host
- Ce sont les ids des users qui vont primer et non les noms

Sur la machine host locale :

#useradd -u 1111 user1
#useradd -u 1112 user2
#mkdir test
#cd test
#vim Dockerfile   : Fichier généralement utilsé pour créer une image

FROM debian:laste    		<---- Image source qu'on souhaite utiliser

RUN	useradd 1111 user1 	  	<---- RUN permey de lancer des commandes shell au moment du build de notre image. On créé un user1 identique à celui sur le host
RUN	useradd 1113 user3		<---- User non existant sur le host
:x!


# docker build -t myimage:v1.0 .    : Crée une image nommée "myimage" . Le "." permet de symboliser le fichier "dockerfile"
# docker images 					:  Pour voir les images contenues sur notre cache local de docker
REPOSITORY  TAG        	IMAGE ID        CREATED   		SIZE
myimage     v1.0       	c8331156e151    14 seconds ago	125MB
nginx		latest 		3f8a00f137a0 	3 weeks ago		142MB
debian		latest		54e726b437fb	3 weeks ago		124MB


# mkdir /myvolume
# docker run -d --name c1 -v /myvolume/:/data/myimage:v1.0   : Crée un conteneur mais qui ne tourne pas en background.
																Il n'est visible qu'avec option -a de "docker ps"
# docker rm -f c1
# docker run -d --name c1 -v /myvolume/:/data/  myimage:v1.0 sleep infinity   : tourne sans arrêt

dans c1:

root@docker1:/home/vagrant/test# docker exec -ti c1 bash  
root@2296f9a074fb:/# ls /data
root@2296f9a074fb:/# touch /data/titi
root@2296f9a074fb:/#

Au niveau host :

root@docker1:/home/vagrant# ls -la /myvolume/
total 8
drwxr-xr-x 2 root root 4096 Маг 3 13:39
drwxr-xr-x 21 root root 4096 Маг 3 13:36 ..
- ٢ - - ٢ - ٢٠ -- 1 root root 0 Маг 3 13:39 titi    <--- Le fichier est créé avec user root car c'est le user par défaut si aucun user spécifié à la creation de l'image

Relançons c1 avec user1:

#docker rm -f c1
# docker run -d --name c1 -v /myvolume/:/data/ -u user1 myimage:v1.0 sleep infinity 

# docker exec -ti c1 bash  	: On est connecté par defaut avec user1 qui n'a pas les droits d'écrire dans /data

Donner les droits à user1 au niveau host (ici owner)
#chown user1 /myvolume

Si on recrée c1 avec user3, user3 ne pourra lire dans /data que si on fait chmod 777 * sur le volume. 
Tout fichier créé par user3 aura l'id 1113 sans nom spécifié au niveau host

NB: On remapper à la création le root du conteneur pour ne pas le fait correspondre au root du host qui a l'id 0

--------------  Les containers runtime 

--OCI : Open Container Initiative

OCI a pour vocation de definir des normes en matière d'images de conteneurs. Ces normes sont sur le depot githud de OCI.
3 elements portés dans OCI :
1.Les layers : couches de filesystems mis les unes sur les autres
2.Les manifets : permettent de definir les architectures possibles pour l'image
3.Les configs : lignes de commandes our arguments dans l'image

Docker CLI est l'interface user en mode terminal qui permet de communiquer avec dockerd, le moteur docker ou container manager.
C'est un conteneur runtime de haut niveau.

Une couche de haut niveau permet d'y rajouter des couches supplementaires sur des conteneurs runtime de bas niveau
Ex: Dockerd permet de faire build ou inspecter une image, pull / push d'images, se connecter à une image avec exec

Dockerd utilise aussi un conteneur runtime haut niveau nommé containerd. Containerd permet de lancer des conteneurs (runc),
administrer le network des conteneurs et faire des bridges

runc : runtime de bas niveau, écrit en Go, permet de lancer les containers avec dockerd et containerd 
runc lance les conteneurs à partir d'images de type oci. Ce principe s'adosse aux principes de Cgroup et Namespaces

Cgroups ou Control Group : limitation des ressources (CPU, mem, NW, disk, priorités) allouées aux processus
Namespaces : isolation (PID, NW, Mount, IPC, UTS(Unix Time-Sharing))

----- Les réseaux docker

*Communication between containers or outside
*Different types: bridge, host, none, overlay...
*Please note that a container does not have a fixed IP (stop/start)

Bridge par defaut : 

	*bridge visible : ip a, ifconfig...
	*default docker0 172.17.0.1 (configurable)
	*docker inspect ...

docker0, le bridge par défaut, permet de fournir des ips à chacun de vos conteneurs dans le reseau 172.17.0.1/16

On peut voir le bridge avec "ip a", "ifconfig" ou "docker network ls" suivi de docker inspect <id du bridge>


Le bridge (ex: docker0)est une couche logique, connectée à notre interface eth (physique ou vrituelle)
Le bridge crée un réseau virtuel à l'intérieur de notre host. Le bridge crée ensuite une interface virtuelle pour chacun de nos conteneurs sous forme de veth (vethernet).
Il sert aussi de gateway pour les autres veth

sudo ifconfig docker0  : voir l'ip attribuée (172.17.0.1) au niveau de notre host (de notre gateway)


docker run --name 1 -d debian sleep infinity
docker exec -ti c1 bash
ip a ou ifconfig   			: pour voir l'ip de l'eth du c1
ping 172.17.0.1  			: pour pinger docker0					
ping 8.8.8.8				: communication possible à l'exterieur du host

NB: Si ip ou ifconfig ne sont pas disponibles comme commandes, faire :

apt update
apt install iputils-ping net-tools 

----- Expose vs Publish

Expose : Métadonnées d'une image prise en compte lors du lancement du conteneur 
		Clause : EXPOSE ou  --expose 

Publish : Mappage de ports soit : 
		• aléatoire -P 
		• defini -p

L'expose reste une métadata. Ce qui ne signifie pas que notre applicatif écoute sur ce port
La publication utilise l'expose 

La publication consiste à mapper un port de notre host avec un port du conteneur.
Ce mapping se fait de manière manuelle avec -p ou dynamique avec -P (ou publish all).
La métadata est utilisée dans le cas aléatoire

On peut faire correspondre le port 80 d'un conteneur nginx avec le port 8080 du host: on parle de publication de port
NB: Il n'existe qu'un seul port de disponible pour notre host de port 80

----------------
Example:

docker run -d --name c1 -p 8080:80 nginx:latest    	: Le 1er port est celui du host et le second pour c1
sudo ifconfig eth1									: pour voir l'adresse de eth1 sur lequel est configuré le bridge (ici 192.168.20.120)

curl 192.168.20.120:8080			: Le conteneur nginx c1 repond alors qu'il écoute sur le port 80


docker run -d --name c2 -P nginx:latest
docker ps
   ...   :::32769->80/tcp				: Une adresse aleatoire a été attribuée et mappée au port c2 definie dans l'image avec EXPOSE

curl 192.168.20.120:8080				: c2 répond
----------------


----   Réseau : IP variable

Un conteneur n'a pas de IP fixe (stop/start). On peut fixer avec DNS ou API/Socket docker

..........docker network : cmds générales ......

docker network.Is/inspect/rm/create
docker network connect/disconnect xxx yyy
docker network inspect yyy
..................................................

...... Pour créer un réseau particulier et attribuer une adresse au conteneur, au lieu de laisser docker0 attribuer dynamiquement :

docker network create mynet [options]
docker run -d --network mynet nginx:latest

example :

docker network ls		: liste les reseaux actuels  [bridge : pour docker0]
docker network create --driver=bridge --subnet=192.168.0.0/24 monreseau0 

$ docker network ls

NETWORK ID		NAME		DRIVER	SCOPE
.....
95a14ef9d256	monreseau0	bridge	local

$ docker network inspect monreseau0
$ docker run -d --name c1 --network monreseau0 nginx:latest
$ docker run -d --name c2 --network monreseau0 nginx:latest
$ docker exec -ti c2 bash
 dans c2 :
 apt update
 apt install iputils-ping
 ping c1
 64 bytes from c1.monreseau0 (192.168.0.2): icmp_seq=1 ttl=64 time=0.073 ms
 
 NB: En utilisant docker0, on ne peut pas pinger c1 à partir de c2
 
A partir de c2 utilisant docker0:

	apt install net-tools
	ifconfig
		eth0: flags=4163<UP, BROADCAST,RUNNING,MULTICAST> mtu 1500
			   inet 172.17.0.2 netmask 255.255.0.0 broadcast 172.17.255.255  : on dispose de docker0

Rattachons c2 et c1 à monreseau0:

$ docker network connect monreseau0 c2
$ docker network connect monreseau0 c1
$ docker inspect c2

NB: Une nouvelle interface sera créée sur c1 et c2 pour monreseau0. Les interfaces pour docker0 sont toujours existantes

# ping c1
64 bytes from c1.monreseau0 (192.168.0.3): icmp_seq=1 ttl=64 time=0.083 ms

............ Driver host

$ docker run -d --name c3 --network host nginx:latest
$ curl 127.0.0.1		: On a une reponse 
$ docker inspect c3 	: Ne donne pas d'ip attribuée à c3 pourtant

--> Si on fait ifconfig dans c3, on retrouve toutes les interfaces comme étant sur le host: on 
	a bypassé le bridge du docker et on a accès à toutes les interfaces et ports directement du host.
	Cette méthode est à éviter sauf dans des cas spécifiques

----------- Reconfigurer Docker0

On a tendance à reconfigurer docker0 pour conserver le range de ips utilisés par les conteneurs avec docker0

Il suffit de configurer le moteur docker dans /etc/docker/daemon.json

#ifconfig docker0		: voir l'ip de docker0

On veut reconfigurer en 10.0.0.1

#vim /etc/docker/daemon.json

	{
	"bip": "10.10.0.1/16
	}

#systemctl restart docker
#ifconfig docker0	

	docker0: flags=4099<UP,BROADCAST,MULTICAST> mtu 1500 inet 10.10.0.1 netmask 255.255.0.0
			broadcast 10.10.255.255

#docker run -d --name c1 debian:latest sleep infinity
#docker inspect c1     : adresse de c1 en 10.0.02 avec gateway en 10.0.0.1

Autre methode : avec un reseau custom toto

#docker network create toto
#docker network  inspect toto  : Il ne nous donne pas de nom de bridge associé à toto

#docker network inspect bridge --> ceci nous donne dans "Options" "com.docker.network.bridge.name": "docker0"

Si on crée un autre reseau titi avec :

# docker network create -o com.docker.network.bridge.name :"titi" titi
#ifconfig 		: donne un nom de bridge "titi"

--------- vethernet et namespace

vethernet : c'est un cable virtuel

On veut brancher ce cable sur une interface du conteneur et un autre bout sur notre bridge

Si on fait ifconfig sur le host, on verra une interface veth*** pour le c1. 
Mais l'adresse mac associée sera differente de celle dans "docker network inspect c1"

------ Network namespace  -----------------------


.................. Resumé
# create a network namespace
ip netns ls
ip netns add alpine_network
ip netns ls
ip netns exec alpine_network ls
ip netns exec alpine_network python3 -m http.server 8000
ip -netns alpine_network a
ip netns exec alpine_network ip link set lo up
ip netns exec alpine_network curl 127.0.0.1:8000
..................

#ip netns ls		: renvoie vide comme liste de namespaces
#ip netns add mynet
#ip netns ls	
		..> mynet			: On peut lancer des commandes à l'intérieur de ce namspace
#ip netns exec mynet ls		: renvoie des fichiers dans le rep courant comme sans un ns 

docker1# ip netns exec mynet python3 -m http.server 8080   -> lancement d'un server web avec python
Serving HTTP on :: port 8080 (http://[::]:8080/) ...

************ Si on se connecte dans un autre terminal à la même machine virtuelle docker1 du dessus :

$v ssh docker1
docker1$ curl 127.0.0.1:8080   --> Connection refused car la commande non exécutée dans le bon ns, une isolation reseau a été faite

Pour vérifier cela, nous allons lancer dans le même ns :

docker1$ ip netns exec mynet curl 127.0.0.1:8080
curl: (7) Couldn't connect to server         ---> L'erreur ici est liée au loopbackup non up dans ns

# ip netns exec mynet ip a
1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN group default qlen 1000   : on a seulement une loopback down

#ip netns exec mynet ip link set lo up
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default glen 1000 : loopback est up

docker1$ ip netns exec mynet curl 127.0.0.1:8080 ->  on a une reponse http car on est dans ns où on a lancé un serveur web utilisant le port 8080

***************************************************


------ Network bridge et namespaces  -----------------------





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































v